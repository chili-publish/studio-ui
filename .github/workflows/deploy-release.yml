name: Deploy Release

on:
    push:
        tags:
            - '*'

env:
    NODE_VERSION: 22.x

jobs:
    validate-tag-release:
        runs-on: ubuntu-latest
        permissions:
            contents: read
        outputs:
            release_exists: ${{ steps.validate_release.outputs.release_exists }}
            tag_name: ${{ steps.validate_release.outputs.tag_name }}
        steps:
            - name: Checkout code
              uses: actions/checkout@v4
              with:
                  ref: ${{ github.ref }}
                  fetch-depth: 0

            - name: Validate GitHub release exists
              id: validate_release
              run: |
                  TAG_NAME=${GITHUB_REF#refs/tags/}
                  echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

                  # Check if a GitHub release exists for this tag
                  # gh release view returns release info if exists, or error message if not
                  if gh release view "$TAG_NAME" >/dev/null 2>&1; then
                    echo "âœ… GitHub release found for tag $TAG_NAME"
                    echo "release_exists=true" >> $GITHUB_OUTPUT
                  else
                    echo "âš ï¸  Warning: Tag $TAG_NAME pushed but no corresponding GitHub release found."
                    echo "âš ï¸  Skipping deployment. Tags should be created via create-release.yml workflow."
                    echo "release_exists=false" >> $GITHUB_OUTPUT
                    exit 0
                  fi
              env:
                  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    detect-release-type:
        needs: [validate-tag-release]
        if: needs.validate-tag-release.outputs.release_exists == 'true'
        runs-on: ubuntu-latest
        permissions:
            contents: read
        outputs:
            is_uat: ${{ steps.detect.outputs.is_uat }}
            is_prd: ${{ steps.detect.outputs.is_prd }}
            tag_name: ${{ steps.detect.outputs.tag_name }}
            version: ${{ steps.detect.outputs.version }}
            environment: ${{ steps.detect.outputs.environment }}
            subscription_id: ${{ steps.detect.outputs.subscription_id }}
            storage_account_name: ${{ steps.detect.outputs.storage_account_name }}
            purge_destination: ${{ steps.detect.outputs.purge_destination }}
        steps:
            - name: Detect release type
              id: detect
              run: |
                  TAG_NAME=${GITHUB_REF#refs/tags/}
                  echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT

                  # Check if tag contains -rc (UAT) or is a clean semver (PRD)
                  # Use bash pattern matching like in create-release.yml
                  if [[ "$TAG_NAME" == *"-rc."* ]]; then
                    echo "is_uat=true" >> $GITHUB_OUTPUT
                    echo "is_prd=false" >> $GITHUB_OUTPUT
                    echo "environment=uat" >> $GITHUB_OUTPUT
                    echo "subscription_id=${{ vars.AZ_SUBSCRIPTION_ID_SAAS_UAT }}" >> $GITHUB_OUTPUT
                    echo "storage_account_name=${{ vars.STORAGE_ACCOUNT_NAME_UAT }}" >> $GITHUB_OUTPUT
                    echo "purge_destination=UAT" >> $GITHUB_OUTPUT
                    echo "Detected UAT release: $TAG_NAME"
                  elif [[ "$TAG_NAME" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                    echo "is_uat=false" >> $GITHUB_OUTPUT
                    echo "is_prd=true" >> $GITHUB_OUTPUT
                    echo "environment=prd" >> $GITHUB_OUTPUT
                    echo "subscription_id=${{ vars.AZ_SUBSCRIPTION_ID_GRAFX_PRD }}" >> $GITHUB_OUTPUT
                    echo "storage_account_name=${{ vars.STORAGE_ACCOUNT_NAME_PROD }}" >> $GITHUB_OUTPUT
                    echo "purge_destination=PRD" >> $GITHUB_OUTPUT
                    echo "Detected PRD release: $TAG_NAME"
                  else
                    echo "âŒ Error: Tag format not recognized. Expected format: X.Y.Z (PRD) or X.Y.Z-rc.N (UAT)"
                    exit 1
                  fi

                  # Extract version from tag (remove v prefix if present)
                  VERSION=$(echo "$TAG_NAME" | sed 's/^v//')
                  echo "version=$VERSION" >> $GITHUB_OUTPUT

    preflight:
        needs: [validate-tag-release]
        if: needs.validate-tag-release.outputs.release_exists == 'true'
        runs-on: ubuntu-latest
        permissions:
            contents: read
        steps:
            - name: Checkout code
              uses: actions/checkout@v4
              with:
                  ref: ${{ github.ref }}

            - name: Check cache
              id: cache
              uses: actions/cache@v4
              with:
                  path: |
                      node_modules
                  key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}-0
                  restore-keys: |
                      ${{ runner.os }}-node-

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: ${{ env.NODE_VERSION }}
                  registry-url: 'https://npm.pkg.github.com'
                  scope: '@chili-publish'

            - name: Install dependencies
              run: yarn install --frozen-lockfile
              env:
                  NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

            - name: Run linting
              run: yarn ci-lint

            - name: Run tests
              run: yarn cover

    deploy-azure:
        needs: [validate-tag-release, detect-release-type, preflight]
        if: needs.validate-tag-release.outputs.release_exists == 'true'
        runs-on: ubuntu-latest
        environment: ${{ needs.detect-release-type.outputs.environment }}
        permissions:
            contents: read
        steps:
            - name: Checkout code
              uses: actions/checkout@v4
              with:
                  ref: ${{ needs.detect-release-type.outputs.tag_name }}

            - name: Check cache
              id: cache
              uses: actions/cache@v4
              with:
                  path: |
                      node_modules
                  key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}-0
                  restore-keys: |
                      ${{ runner.os }}-node-

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: ${{ env.NODE_VERSION }}
                  registry-url: 'https://npm.pkg.github.com'
                  scope: '@chili-publish'

            - name: Install dependencies
              run: yarn install --frozen-lockfile
              env:
                  NODE_AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

            - name: Build code
              run: yarn build

            - name: Prepare CDN upload
              run: |
                  export CURRENT_PACKAGE_VERSION="${{ needs.detect-release-type.outputs.version }}"
                  # Extract major.minor and patch (including -rc suffix if present)
                  export PACKAGE_VERSION_TRIMMED=$(node --eval="const version = '$CURRENT_PACKAGE_VERSION'.split('.'); const path = version[0] + '.' + version[1]; console.log(path)")
                  export PACKAGE_VERSION_PATCH=$(node --eval="const version = '$CURRENT_PACKAGE_VERSION'.split('.'); const patch = version.slice(2).join('.'); console.log(patch)")

                  buildPath=upload/$PACKAGE_VERSION_TRIMMED/$PACKAGE_VERSION_PATCH
                  latestPath=upload/latest
                  versionedLatestPath=upload/$PACKAGE_VERSION_TRIMMED/latest

                  mkdir -p ${buildPath%"/merge"}
                  mkdir -p ${latestPath%"/merge"}
                  mkdir -p ${versionedLatestPath%"/merge"}

                  cp -R dist/* ${buildPath%"/merge"}
                  cp -R dist/* ${latestPath%"/merge"}
                  cp -R dist/* ${versionedLatestPath%"/merge"}

            - name: Azure Login
              uses: azure/login@v2
              with:
                  creds: >-
                      {
                        "clientId": "${{ vars.AZ_AD_CLIENT_ID_CP_RJS_INT_CICD_SP }}",
                        "clientSecret": "${{ secrets.AZ_AD_CLIENT_SECRET_CP_RJS_INT_CICD_SP }}",
                        "tenantId": "${{ vars.AZ_TENANT_ID }}",
                        "subscriptionId": "${{ needs.detect-release-type.outputs.subscription_id }}"
                      }

            - name: Copy Studio UI to Azure Blob Storage
              uses: azure/cli@v2
              with:
                  inlineScript: |
                      az storage blob upload-batch \
                        --account-name "${{ needs.detect-release-type.outputs.storage_account_name }}" \
                        --destination studio-ui \
                        --source upload/ \
                        --overwrite true \
                        --auth-mode login

    purge-cdn:
        needs: [validate-tag-release, detect-release-type, deploy-azure]
        if: needs.validate-tag-release.outputs.release_exists == 'true'
        name: Cloudflare CDN purge
        runs-on: ubuntu-latest
        steps:
            - name: Get GitHub App Access Token
              id: github-app-access-token
              uses: actions/create-github-app-token@v2
              with:
                  app-id: ${{ vars.GH_APP_ID_CHILI_FRONTEND_VERSION_MANAGER }}
                  private-key: ${{ secrets.GH_APP_PRIVATE_KEY_CHILI_FRONTEND_VERSION_MANAGER }}
                  owner: ${{ github.repository_owner }}

            - name: Dispatch Cloudflare CDN Purge Action
              id: dispatch-cloudflare-cdn-purge
              run: |
                  curl -L -X POST \
                  -H "Accept: application/vnd.github+json" \
                  -H "Authorization: Bearer ${{ steps.github-app-access-token.outputs.token }}" \
                  -H "X-GitHub-Api-Version: 2022-11-28" \
                  https://api.github.com/repos/chili-publish/delivery-infrastructure/actions/workflows/ops-cloudflare-cdn-purge.yml/dispatches \
                  -d '{"ref":"main","inputs":{"destination":"${{ needs.detect-release-type.outputs.purge_destination }}","purge-prefixes":"studio-ui"}}'

    notify:
        needs: [validate-tag-release, detect-release-type, deploy-azure]
        if: needs.validate-tag-release.outputs.release_exists == 'true'
        runs-on: ubuntu-latest
        permissions: {}
        steps:
            - name: Notify Teams
              run: |
                  VERSION="${{ needs.detect-release-type.outputs.version }}"
                  TAG_NAME="${{ needs.detect-release-type.outputs.tag_name }}"
                  RELEASE_TYPE="${{ needs.detect-release-type.outputs.is_uat == 'true' && 'UAT' || 'Production' }}"
                  EMOJI="${{ needs.detect-release-type.outputs.is_uat == 'true' && 'ðŸ§ª' || 'ðŸŽ‰' }}"

                  payload=$(cat <<EOF
                  {
                      "text": "$EMOJI **$RELEASE_TYPE Deployment Completed**\n\n**Version:** $VERSION\n**Tag:** $TAG_NAME\n\nDeployment to $RELEASE_TYPE environment completed successfully."
                  }
                  EOF
                  )
                  curl --request POST \
                  --header "Content-Type: application/json" \
                  --data "$payload" \
                  "${{ secrets.TEAMS_RELEASE_HOOK_URL }}"

    bump-main-version:
        needs: [validate-tag-release, detect-release-type, deploy-azure]
        if: needs.validate-tag-release.outputs.release_exists == 'true' && needs.detect-release-type.outputs.is_prd == 'true'
        runs-on: ubuntu-latest
        permissions:
            contents: write
        env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        steps:
            - name: Get GitHub App Access Token
              id: github-app-access-token
              uses: actions/create-github-app-token@v2
              with:
                  app-id: ${{ vars.GH_APP_ID_CHILI_FRONTEND_VERSION_MANAGER }}
                  private-key: ${{ secrets.GH_APP_PRIVATE_KEY_CHILI_FRONTEND_VERSION_MANAGER }}
                  owner: ${{ github.repository_owner }}

            - name: Checkout main branch
              uses: actions/checkout@v4
              with:
                  ref: main
                  token: ${{ steps.github-app-access-token.outputs.token }}
                  fetch-depth: 0

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version: ${{ env.NODE_VERSION }}

            - name: Check cache
              id: cache
              uses: actions/cache@v4
              with:
                  path: |
                      node_modules
                  key: ${{ runner.os }}-node-${{ hashFiles('**/yarn.lock') }}-0
                  restore-keys: |
                      ${{ runner.os }}-node-

            - name: Install dependencies
              run: yarn install --frozen-lockfile

            - name: Check if hotfix release
              id: check_hotfix
              run: |
                  CURRENT_TAG="${{ needs.detect-release-type.outputs.version }}"

                  # Get previous production release (skip the current release)
                  # Get all production releases and filter out the current tag, then take the first one
                  PREVIOUS_TAG=$(gh release list --limit 10 --json isPrerelease,tagName --jq ".[] | select(.isPrerelease == false) | select(.tagName != \"$CURRENT_TAG\") | .tagName" | head -1)

                  if [ -z "$PREVIOUS_TAG" ]; then
                    echo "is_hotfix=false" >> $GITHUB_OUTPUT
                    echo "No previous release found, assuming regular release"
                    exit 0
                  fi

                  # Extract major.minor from both versions
                  CURRENT_MINOR=$(echo "$CURRENT_TAG" | cut -d. -f1,2)
                  PREVIOUS_MINOR=$(echo "$PREVIOUS_TAG" | cut -d. -f1,2)

                  # If minor version is the same, it's a hotfix (patch increment)
                  if [ "$CURRENT_MINOR" = "$PREVIOUS_MINOR" ]; then
                    echo "is_hotfix=true" >> $GITHUB_OUTPUT
                    echo "Detected hotfix release (minor version unchanged: $CURRENT_MINOR)"
                  else
                    echo "is_hotfix=false" >> $GITHUB_OUTPUT
                    echo "Detected regular release (minor version changed: $PREVIOUS_MINOR -> $CURRENT_MINOR)"
                  fi

            - name: Get current version
              id: current_version
              if: steps.check_hotfix.outputs.is_hotfix != 'true'
              run: |
                  VERSION=$(node -p "require('./package.json').version")
                  echo "current_version=$VERSION" >> $GITHUB_OUTPUT
                  echo "Current version in main: $VERSION"

            - name: Bump to next minor alpha
              if: steps.check_hotfix.outputs.is_hotfix != 'true'
              id: bump_version
              run: |
                  git config --global user.name 'github-actions[bot]'
                  git config --global user.email 'github-actions[bot]@users.noreply.github.com'

                  # Calculate next minor version with alpha.0 (only for regular production releases)
                  NEW_VERSION=$(npm version preminor --preid=alpha --git-tag-version=false)

                  # Remove 'v' prefix if present
                  NEXT_VERSION=$(echo $NEW_VERSION | sed 's/^v//')

                  echo "new_version=$NEXT_VERSION" >> $GITHUB_OUTPUT
                  echo "Bumped version to: $NEXT_VERSION"

            - name: Commit and push version bump
              if: steps.check_hotfix.outputs.is_hotfix != 'true'
              run: |
                  git add package.json yarn.lock || true
                  git commit -m "chore: bump version to ${{ steps.bump_version.outputs.new_version }} for next dev cycle [skip ci]"
                  git push origin main
                  echo "Pushed version bump to main branch"
